{
    "collab_server" : "",
    "contents" : "# Unit test two way functions\n#define the functions with associatied parameters to scale the amount of noise added\nlinear <- function(x, noise, noiseLevel, numNoise, n) {x + noise *(noiseLevel/numNoise)* rnorm(n)}\n\nquadratic <- function(x, noise, noiseLevel, numNoise, n) { 4*(x-.5)^2+  noise * (noiseLevel/numNoise) * rnorm(n)}\n\ncubic <- function(x, noise, noiseLevel, numNoise, n) {\n  128*(x-1/3)^3 -48*(x-1/3)^3-12*(x-1/3)+10* noise  * (noiseLevel/numNoise) *rnorm(n)\n}\nqroot <- function(x, noise, noiseLevel, numNoise, n) {\n  x^(1/4) + noise * (noiseLevel/numNoise) *rnorm(n)\n}\n\nexponential2 <- function(x, noise, noiseLevel, numNoise, n){ exp(x^2) + (1.5 *noise * (noiseLevel/numNoise) * rnorm(n))}\nlogE <- function(x, noise, noiseLevel, numNoise, n) { log(x) + 2 * (noise * (noiseLevel/numNoise) * rnorm(n))}\n\nsigmoid <- function(x, noise, noiseLevel, numNoise, n) {((1 + exp(10*(0.5 - x)))^-1) +( noise * (noiseLevel/numNoise) * rnorm(n))}\nstep <- function(x, noise, noiseLevel, numNoise, n) { (x > 0.5) + noise*5*noiseLevel/numNoise *rnorm(n) }\n\nspike <- function(x, noise, noiseLevel, numNoise, n) {\n  v <- vector('numeric', n)\n  for (i in seq_along(x)) {\n    if (x[i] < 0.05) {\n      v[i] <- 4\n    } else if(x[i] < 0.1) {\n      v[i] <- -18*x[i] + 1.9\n    } else {\n      v[i] <- -x[i]/9 + 1/9\n    }\n  }\n  \n  v + noise*5*noiseLevel/numNoise *rnorm(n)\n}\n\nsinLow <- function(x, noise, noiseLevel, numNoise, n) { sin(4*pi*x) + 2*noise * (noiseLevel/numNoise) *rnorm(n)}\n\nsinHigh <- function(x, noise, noiseLevel, numNoise, n) { sin(16*pi*x) + 2*noise * (noiseLevel/numNoise) *rnorm(n)}\nlinearPeriodic <- function(x, noise, noiseLevel, numNoise, n) { sin(10*pi*x) + x + 3*noise * (noiseLevel/numNoise) *rnorm(n)}\n\nvaryingFreq <- function(x, noise, noiseLevel, numNoise, n) { sin(5*pi*x*(1+x)) + x + 3*noise * (noiseLevel/numNoise) *rnorm(n)}\n\ncircle <- function(x, noise, noiseLevel, numNoise, n) {(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*noiseLevel/numNoise *rnorm(n)}\nxShaped <- function(x, noise, noiseLevel, numNoise, n) {((4*(x-.5)^2 + (noiseLevel/numNoise) * rnorm(n)) * sample( c(-1,1), size=n, replace=T ) )}\n\n\ntest_that(\"linear implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- linear(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- linearCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\ntest_that(\"quadratic implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- quadratic(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- quadraticCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\ntest_that(\"cubic implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- cubic(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- cubicCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\ntest_that(\"qroot implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- qroot(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- qrootCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\ntest_that(\"exponential implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- exponential2(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- exponentialCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp, tolerance = .000001)\n})\n\ntest_that(\"Natural log implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- logE(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- logECpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\ntest_that(\"Sigmoid implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- sigmoid(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- sigmoidCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\ntest_that(\"Step implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- step(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- stepCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\ntest_that(\"Spike implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- spike(x, 2, 10, 30, 10)\n  set.seed(1)\n  ycpp <- spikeCpp(x, 2, 10, 30, 10)\n  expect_equal(y, ycpp, tolerance = 0.01)\n})\n\ntest_that(\"Sine low implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- sinLow(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- sinLowCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\ntest_that(\"Sine high implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- sinHigh(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- sinHighCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\ntest_that(\"Linear periodic implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- linearPeriodic(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- linearPeriodicCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\ntest_that(\"Varying freq implementations are equal\", {\n  set.seed(1)\n  x <- runif(10)\n  set.seed(1)\n  y <- varyingFreq(x, 3, 10, 30, 10)\n  set.seed(1)\n  ycpp <- varyingFreqCpp(x, 3, 10, 30, 10)\n  expect_equal(y, ycpp)\n})\n\n#circle and x rely on random sampling so testing is awkward\n\n\n",
    "created" : 1481719489893.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2417434347",
    "id" : "36D63DF8",
    "lastKnownWriteTime" : 1481719497,
    "last_content_update" : 1481719497818,
    "path" : "D:/projects/nlf/tests/testthat/testTwoWay.R",
    "project_path" : "tests/testthat/testTwoWay.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}